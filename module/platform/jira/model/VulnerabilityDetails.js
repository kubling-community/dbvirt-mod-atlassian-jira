/**
 * Jira Software Cloud API
 * Jira Software Cloud REST API documentation
 *
 * The version of the OpenAPI document: 1001.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import Identifier from './Identifier';
import VulnerabilityAdditionalInfo from './VulnerabilityAdditionalInfo';
import VulnerabilityDetailsAddAssociationsInner from './VulnerabilityDetailsAddAssociationsInner';
import VulnerabilitySeverity from './VulnerabilitySeverity';

/**
 * The VulnerabilityDetails model module.
 * @module model/VulnerabilityDetails
 * @version 1001.0.0
 */
class VulnerabilityDetails {
    /**
     * Constructs a new <code>VulnerabilityDetails</code>.
     * Data related to a specific vulnerability in a specific workspace that the vulnerability is present in. Must specify at least one association. 
     * @alias module:model/VulnerabilityDetails
     * @param schemaVersion {module:model/VulnerabilityDetails.SchemaVersionEnum} The VulnerabilityData schema version used for this vulnerability data.  Placeholder to support potential schema changes in the future. 
     * @param id {String} The identifier for the Vulnerability. Must be unique for a given Provider. 
     * @param updateSequenceNumber {Number} An ID used to apply an ordering to updates for this Vulnerability in the case of out-of-order receipt of update requests.  This can be any monotonically increasing number. A suggested implementation is to use epoch millis from the Provider system, but other alternatives are valid (e.g. a Provider could store a counter against each Vulnerability and increment that on each update to Jira).  Updates for a Vulnerability that are received with an updateSequenceId lower than what is currently stored will be ignored. 
     * @param containerId {String} The identifier of the Container where this Vulnerability was found. Must be unique for a given Provider. This must follow this regex pattern: `[a-zA-Z0-9\\\\-_.~@:{}=]+(/[a-zA-Z0-9\\\\-_.~@:{}=]+)*` 
     * @param displayName {String} The human-readable name for the Vulnerability. Will be shown in the UI.  If not provided, will use the ID for display. 
     * @param description {String} A description of the issue in markdown format that will be shown in the UI and used when creating Jira Issues. HTML tags are not supported in the markdown format. For creating a new line `\\n` can be used. Read more about the accepted markdown transformations [here](https://atlaskit.atlassian.com/packages/editor/editor-markdown-transformer). 
     * @param url {String} A URL users can use to link to a summary view of this vulnerability, if appropriate.  This could be any location that makes sense in the Provider system (e.g. if the summary information comes from a specific project, it might make sense to link the user to the vulnerability in that project). 
     * @param type {module:model/VulnerabilityDetails.TypeEnum} The type of Vulnerability detected.
     * @param introducedDate {Date} The timestamp to present to the user that shows when the Vulnerability was introduced.  Expected format is an RFC3339 formatted string. 
     * @param lastUpdated {Date} The last-updated timestamp to present to the user the last time the Vulnerability was updated.  Expected format is an RFC3339 formatted string. 
     * @param severity {module:model/VulnerabilitySeverity} 
     * @param status {module:model/VulnerabilityDetails.StatusEnum} The current status of the Vulnerability. 
     */
    constructor(schemaVersion, id, updateSequenceNumber, containerId, displayName, description, url, type, introducedDate, lastUpdated, severity, status) { 
        
        VulnerabilityDetails.initialize(this, schemaVersion, id, updateSequenceNumber, containerId, displayName, description, url, type, introducedDate, lastUpdated, severity, status);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj, schemaVersion, id, updateSequenceNumber, containerId, displayName, description, url, type, introducedDate, lastUpdated, severity, status) { 
        obj['schemaVersion'] = schemaVersion || '1.0';
        obj['id'] = id;
        obj['updateSequenceNumber'] = updateSequenceNumber;
        obj['containerId'] = containerId;
        obj['displayName'] = displayName;
        obj['description'] = description;
        obj['url'] = url;
        obj['type'] = type;
        obj['introducedDate'] = introducedDate;
        obj['lastUpdated'] = lastUpdated;
        obj['severity'] = severity;
        obj['status'] = status;
    }

    /**
     * Constructs a <code>VulnerabilityDetails</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/VulnerabilityDetails} obj Optional instance to populate.
     * @return {module:model/VulnerabilityDetails} The populated <code>VulnerabilityDetails</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new VulnerabilityDetails();

            if (data.hasOwnProperty('schemaVersion')) {
                obj['schemaVersion'] = ApiClient.convertToType(data['schemaVersion'], 'String');
            }
            if (data.hasOwnProperty('id')) {
                obj['id'] = ApiClient.convertToType(data['id'], 'String');
            }
            if (data.hasOwnProperty('updateSequenceNumber')) {
                obj['updateSequenceNumber'] = ApiClient.convertToType(data['updateSequenceNumber'], 'Number');
            }
            if (data.hasOwnProperty('containerId')) {
                obj['containerId'] = ApiClient.convertToType(data['containerId'], 'String');
            }
            if (data.hasOwnProperty('displayName')) {
                obj['displayName'] = ApiClient.convertToType(data['displayName'], 'String');
            }
            if (data.hasOwnProperty('description')) {
                obj['description'] = ApiClient.convertToType(data['description'], 'String');
            }
            if (data.hasOwnProperty('url')) {
                obj['url'] = ApiClient.convertToType(data['url'], 'String');
            }
            if (data.hasOwnProperty('type')) {
                obj['type'] = ApiClient.convertToType(data['type'], 'String');
            }
            if (data.hasOwnProperty('introducedDate')) {
                obj['introducedDate'] = ApiClient.convertToType(data['introducedDate'], 'Date');
            }
            if (data.hasOwnProperty('lastUpdated')) {
                obj['lastUpdated'] = ApiClient.convertToType(data['lastUpdated'], 'Date');
            }
            if (data.hasOwnProperty('severity')) {
                obj['severity'] = VulnerabilitySeverity.constructFromObject(data['severity']);
            }
            if (data.hasOwnProperty('identifiers')) {
                obj['identifiers'] = ApiClient.convertToType(data['identifiers'], [Identifier]);
            }
            if (data.hasOwnProperty('status')) {
                obj['status'] = ApiClient.convertToType(data['status'], 'String');
            }
            if (data.hasOwnProperty('additionalInfo')) {
                obj['additionalInfo'] = VulnerabilityAdditionalInfo.constructFromObject(data['additionalInfo']);
            }
            if (data.hasOwnProperty('addAssociations')) {
                obj['addAssociations'] = ApiClient.convertToType(data['addAssociations'], [VulnerabilityDetailsAddAssociationsInner]);
            }
            if (data.hasOwnProperty('removeAssociations')) {
                obj['removeAssociations'] = ApiClient.convertToType(data['removeAssociations'], [VulnerabilityDetailsAddAssociationsInner]);
            }
            if (data.hasOwnProperty('associationsLastUpdated')) {
                obj['associationsLastUpdated'] = ApiClient.convertToType(data['associationsLastUpdated'], 'Date');
            }
            if (data.hasOwnProperty('associationsUpdateSequenceNumber')) {
                obj['associationsUpdateSequenceNumber'] = ApiClient.convertToType(data['associationsUpdateSequenceNumber'], 'Number');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>VulnerabilityDetails</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>VulnerabilityDetails</code>.
     */
    static validateJSON(data) {
        // check to make sure all required properties are present in the JSON string
        for (const property of VulnerabilityDetails.RequiredProperties) {
            if (!data.hasOwnProperty(property)) {
                throw new Error("The required field `" + property + "` is not found in the JSON data: " + JSON.stringify(data));
            }
        }
        // ensure the json data is a string
        if (data['schemaVersion'] && !(typeof data['schemaVersion'] === 'string' || data['schemaVersion'] instanceof String)) {
            throw new Error("Expected the field `schemaVersion` to be a primitive type in the JSON string but got " + data['schemaVersion']);
        }
        // ensure the json data is a string
        if (data['id'] && !(typeof data['id'] === 'string' || data['id'] instanceof String)) {
            throw new Error("Expected the field `id` to be a primitive type in the JSON string but got " + data['id']);
        }
        // ensure the json data is a string
        if (data['containerId'] && !(typeof data['containerId'] === 'string' || data['containerId'] instanceof String)) {
            throw new Error("Expected the field `containerId` to be a primitive type in the JSON string but got " + data['containerId']);
        }
        // ensure the json data is a string
        if (data['displayName'] && !(typeof data['displayName'] === 'string' || data['displayName'] instanceof String)) {
            throw new Error("Expected the field `displayName` to be a primitive type in the JSON string but got " + data['displayName']);
        }
        // ensure the json data is a string
        if (data['description'] && !(typeof data['description'] === 'string' || data['description'] instanceof String)) {
            throw new Error("Expected the field `description` to be a primitive type in the JSON string but got " + data['description']);
        }
        // ensure the json data is a string
        if (data['url'] && !(typeof data['url'] === 'string' || data['url'] instanceof String)) {
            throw new Error("Expected the field `url` to be a primitive type in the JSON string but got " + data['url']);
        }
        // ensure the json data is a string
        if (data['type'] && !(typeof data['type'] === 'string' || data['type'] instanceof String)) {
            throw new Error("Expected the field `type` to be a primitive type in the JSON string but got " + data['type']);
        }
        // validate the optional field `severity`
        if (data['severity']) { // data not null
          VulnerabilitySeverity.validateJSON(data['severity']);
        }
        if (data['identifiers']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['identifiers'])) {
                throw new Error("Expected the field `identifiers` to be an array in the JSON data but got " + data['identifiers']);
            }
            // validate the optional field `identifiers` (array)
            for (const item of data['identifiers']) {
                Identifier.validateJSON(item);
            };
        }
        // ensure the json data is a string
        if (data['status'] && !(typeof data['status'] === 'string' || data['status'] instanceof String)) {
            throw new Error("Expected the field `status` to be a primitive type in the JSON string but got " + data['status']);
        }
        // validate the optional field `additionalInfo`
        if (data['additionalInfo']) { // data not null
          VulnerabilityAdditionalInfo.validateJSON(data['additionalInfo']);
        }
        if (data['addAssociations']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['addAssociations'])) {
                throw new Error("Expected the field `addAssociations` to be an array in the JSON data but got " + data['addAssociations']);
            }
            // validate the optional field `addAssociations` (array)
            for (const item of data['addAssociations']) {
                VulnerabilityDetailsAddAssociationsInner.validateJSON(item);
            };
        }
        if (data['removeAssociations']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['removeAssociations'])) {
                throw new Error("Expected the field `removeAssociations` to be an array in the JSON data but got " + data['removeAssociations']);
            }
            // validate the optional field `removeAssociations` (array)
            for (const item of data['removeAssociations']) {
                VulnerabilityDetailsAddAssociationsInner.validateJSON(item);
            };
        }

        return true;
    }


}

VulnerabilityDetails.RequiredProperties = ["schemaVersion", "id", "updateSequenceNumber", "containerId", "displayName", "description", "url", "type", "introducedDate", "lastUpdated", "severity", "status"];

/**
 * The VulnerabilityData schema version used for this vulnerability data.  Placeholder to support potential schema changes in the future. 
 * @member {module:model/VulnerabilityDetails.SchemaVersionEnum} schemaVersion
 * @default '1.0'
 */
VulnerabilityDetails.prototype['schemaVersion'] = '1.0';

/**
 * The identifier for the Vulnerability. Must be unique for a given Provider. 
 * @member {String} id
 */
VulnerabilityDetails.prototype['id'] = undefined;

/**
 * An ID used to apply an ordering to updates for this Vulnerability in the case of out-of-order receipt of update requests.  This can be any monotonically increasing number. A suggested implementation is to use epoch millis from the Provider system, but other alternatives are valid (e.g. a Provider could store a counter against each Vulnerability and increment that on each update to Jira).  Updates for a Vulnerability that are received with an updateSequenceId lower than what is currently stored will be ignored. 
 * @member {Number} updateSequenceNumber
 */
VulnerabilityDetails.prototype['updateSequenceNumber'] = undefined;

/**
 * The identifier of the Container where this Vulnerability was found. Must be unique for a given Provider. This must follow this regex pattern: `[a-zA-Z0-9\\\\-_.~@:{}=]+(/[a-zA-Z0-9\\\\-_.~@:{}=]+)*` 
 * @member {String} containerId
 */
VulnerabilityDetails.prototype['containerId'] = undefined;

/**
 * The human-readable name for the Vulnerability. Will be shown in the UI.  If not provided, will use the ID for display. 
 * @member {String} displayName
 */
VulnerabilityDetails.prototype['displayName'] = undefined;

/**
 * A description of the issue in markdown format that will be shown in the UI and used when creating Jira Issues. HTML tags are not supported in the markdown format. For creating a new line `\\n` can be used. Read more about the accepted markdown transformations [here](https://atlaskit.atlassian.com/packages/editor/editor-markdown-transformer). 
 * @member {String} description
 */
VulnerabilityDetails.prototype['description'] = undefined;

/**
 * A URL users can use to link to a summary view of this vulnerability, if appropriate.  This could be any location that makes sense in the Provider system (e.g. if the summary information comes from a specific project, it might make sense to link the user to the vulnerability in that project). 
 * @member {String} url
 */
VulnerabilityDetails.prototype['url'] = undefined;

/**
 * The type of Vulnerability detected.
 * @member {module:model/VulnerabilityDetails.TypeEnum} type
 */
VulnerabilityDetails.prototype['type'] = undefined;

/**
 * The timestamp to present to the user that shows when the Vulnerability was introduced.  Expected format is an RFC3339 formatted string. 
 * @member {Date} introducedDate
 */
VulnerabilityDetails.prototype['introducedDate'] = undefined;

/**
 * The last-updated timestamp to present to the user the last time the Vulnerability was updated.  Expected format is an RFC3339 formatted string. 
 * @member {Date} lastUpdated
 */
VulnerabilityDetails.prototype['lastUpdated'] = undefined;

/**
 * @member {module:model/VulnerabilitySeverity} severity
 */
VulnerabilityDetails.prototype['severity'] = undefined;

/**
 * The identifying information for the Vulnerability. 
 * @member {Array.<module:model/Identifier>} identifiers
 */
VulnerabilityDetails.prototype['identifiers'] = undefined;

/**
 * The current status of the Vulnerability. 
 * @member {module:model/VulnerabilityDetails.StatusEnum} status
 */
VulnerabilityDetails.prototype['status'] = undefined;

/**
 * @member {module:model/VulnerabilityAdditionalInfo} additionalInfo
 */
VulnerabilityDetails.prototype['additionalInfo'] = undefined;

/**
 * The associations (e.g. Jira issue) to add in addition to the currently stored associations of the Security Vulnerability. 
 * @member {Array.<module:model/VulnerabilityDetailsAddAssociationsInner>} addAssociations
 */
VulnerabilityDetails.prototype['addAssociations'] = undefined;

/**
 * The associations (e.g. Jira issue) to remove from currently stored associations of the Security Vulnerability. 
 * @member {Array.<module:model/VulnerabilityDetailsAddAssociationsInner>} removeAssociations
 */
VulnerabilityDetails.prototype['removeAssociations'] = undefined;

/**
 * An ISO-8601 Date-time string representing the last time the provider updated associations on this entity.  Expected format is an RFC3339 formatted string. 
 * @member {Date} associationsLastUpdated
 */
VulnerabilityDetails.prototype['associationsLastUpdated'] = undefined;

/**
 * A sequence number to compare when writing entity associations to the database.  This can be any monotonically increasing number. A highly recommended implementation is to use epoch millis.  This is an optional field. If it is not provided it will default to being equal to the corresponding entity's `updateSequenceNumber`.  Associations are written following a LastWriteWins strategy, association that are received with an associationsUpdateSequenceNumber lower than what is currently stored will be ignored. 
 * @member {Number} associationsUpdateSequenceNumber
 */
VulnerabilityDetails.prototype['associationsUpdateSequenceNumber'] = undefined;





/**
 * Allowed values for the <code>schemaVersion</code> property.
 * @enum {String}
 * @readonly
 */
VulnerabilityDetails['SchemaVersionEnum'] = {

    /**
     * value: "1.0"
     * @const
     */
    "1.0": "1.0"
};


/**
 * Allowed values for the <code>type</code> property.
 * @enum {String}
 * @readonly
 */
VulnerabilityDetails['TypeEnum'] = {

    /**
     * value: "sca"
     * @const
     */
    "sca": "sca",

    /**
     * value: "sast"
     * @const
     */
    "sast": "sast",

    /**
     * value: "dast"
     * @const
     */
    "dast": "dast",

    /**
     * value: "unknown"
     * @const
     */
    "unknown": "unknown"
};


/**
 * Allowed values for the <code>status</code> property.
 * @enum {String}
 * @readonly
 */
VulnerabilityDetails['StatusEnum'] = {

    /**
     * value: "open"
     * @const
     */
    "open": "open",

    /**
     * value: "closed"
     * @const
     */
    "closed": "closed",

    /**
     * value: "ignored"
     * @const
     */
    "ignored": "ignored",

    /**
     * value: "unknown"
     * @const
     */
    "unknown": "unknown"
};



export default VulnerabilityDetails;

